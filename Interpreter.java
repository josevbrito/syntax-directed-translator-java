import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.stream.Collectors;


/**
 * Command.java
 * Helper class to represent a single command.
 */
class Command {
    public enum Type {
        ADD, SUB, PUSH, POP, PRINT
    }

    public Command.Type type;
    public String arg = "";

    public Command(String[] command) {
        type = Command.Type.valueOf(command[0].toUpperCase());
        if (command.length > 1) {
            arg = command[1];
        }
    }

    public String toString() {
        return type.name() + " " + arg;
    }
}



/**
 * Interpreter.java
 * Implements a simple stack-based virtual machine to execute the code generated by the Parser.
 */
public class Interpreter {

    List<String[]> commands;
    Stack<Integer> stack = new Stack<>(); // The operand stack
    Map<String, Integer> variables = new HashMap<>(); // The "memory" for variables

    /**
     * Constructor for the Interpreter.
     */
    public Interpreter(String input) {
        final String eol = System.getProperty("line.separator");
        var output = input.split(eol);
        commands = Arrays.stream(output)
            .map(String::strip)
            .filter((s) -> !s.startsWith("//") && !s.isEmpty())
            .map((s) -> s.split(" "))
            .collect(Collectors.toList());
    }

    public boolean hasMoreCommands() {
        return !commands.isEmpty();
    }

    public Command nextCommand() {
        return new Command(commands.remove(0));
    }

    /**
     * Runs the interpreter, executing all commands.
     */
    public void run() {
        while (hasMoreCommands()) {
            var command = nextCommand();
            switch (command.type) {
                case ADD: {
                    var arg2 = stack.pop();
                    var arg1 = stack.pop();
                    stack.push(arg1 + arg2);
                    break;
                }
                case SUB: {
                    var arg2 = stack.pop();
                    var arg1 = stack.pop();
                    stack.push(arg1 - arg2);
                    break;
                }
                case PUSH: {
                    // If the argument is a variable, push its value.
                    // Otherwise, push the literal number.
                    var value = variables.get(command.arg);
                    if (value != null) {
                        stack.push(value);
                    } else {
                        stack.push(Integer.parseInt(command.arg));
                    }
                    break;
                }
                case POP: {
                    // Pops a value from the stack and stores it in the "memory" for variables.
                    var value = stack.pop();
                    variables.put(command.arg, value);
                    break;
                }
                case PRINT: {
                    var arg = stack.pop();
                    System.out.println(arg);
                    break;
                }
            }
        }
    }
}